# Portf√≥lio SQL üìä

## Brazil Delivery Center 

### Contexto e explica√ß√£o do problema

Tenho me dedicado a aprimorar meus conhecimentos em SQL e recentemente finalizei uma atividade pr√°tica focada em an√°lise de dados. J√° havia aprendido SQL por conta pr√≥pria, do zero, complementando com cursos na Udemy. Essa pr√°tica compartilhada aqui, refor√ßou ainda mais meu entendimento da linguagem.

Nesse projeto h√° tr√™s perguntas que busquei responder com dados previamente baixados na plataforma Kaggle. Tive liberdade para escolher qual SGBD utilizar na an√°lise. Baixei e testei tr√™s op√ß√µes: SQL Server, pgAdmin e PostgreSQL. Embora tenha achado o PostgreSQL mais interessante e semelhante ao R, com o qual tenho mais familiaridade, optei pelo SQL Server pela maior disponibilidade de f√≥runs e materiais de apoio encontrados na internet.

A escolha do banco de dados considerou alguns crit√©rios: [i] que houvesse mais de duas tabelas, j√° que um dos principais objetivos era praticar o uso de joins, [ii] que existissem colunas em comum entre elas [iii] e que o n√∫mero de linhas fosse suficientemente representativo. A inten√ß√£o √©, posteriormente, aplicar an√°lises estat√≠sticas mais avan√ßadas, como regress√µes, utilizando o R, com base nos conhecimentos adquiridos na p√≥s-gradua√ß√£o stricto sensu.

### Vamos ao assunto principal:

Neste projeto, utilizo o banco de dados Delivery Center: Food & Goods orders in Brazil, que cont√©m sete tabelas principais, utilizadas para responder √†s perguntas propostas. Abaixo, segue a descri√ß√£o de cada uma:

- channels: cont√©m informa√ß√µes sobre os canais de venda (marketplaces) utilizados pelos lojistas para vender alimentos (food) e produtos (goods).
- deliveries: re√∫ne dados sobre as entregas realizadas por entregadores parceiros.
- drivers: apresenta informa√ß√µes sobre os entregadores parceiros, que atuam a partir dos hubs para entregar os pedidos aos consumidores.
- hubs: cont√©m dados sobre os centros de distribui√ß√£o (hubs) de onde partem as entregas.
- orders: re√∫ne informa√ß√µes sobre as vendas processadas pela plataforma do Delivery Center.
- payments: apresenta dados sobre os pagamentos feitos ao Delivery Center.
- stores: traz informa√ß√µes sobre os lojistas que utilizam a plataforma para vender seus produtos nos marketplaces.
  
Aqui est√° a figura disponibilizada pelo autor do diagrama de modelo de dados.

<img width="1489" height="716" alt="Image" src="https://github.com/user-attachments/assets/a7de357a-d315-4948-bff4-4d24cd05c0b4" />
Imagem 1: Explica√ß√£o da tabela. Fonte: https://www.linkedin.com/in/cleibsonalmeida/

#### As perguntas e as respostas

A seguir, apresento as tr√™s perguntas que devem ser respondidas utilizando algumas das tabelas mencionadas acima. Em cada item, trarei a pergunta, a descri√ß√£o e, em seguida, a respectiva resposta.

### Pergunta, Descri√ß√£o e Resposta 1
#### Quest√£o 1

Qual a taxa de sucesso de entregas (status = ‚ÄúEntregue‚Äù) entre freelancers e operadores? Existe diferen√ßa significativa?

#### Descri√ß√£o 1

A partir da pergunta acima, defini quais colunas precisavam estar presentes no resultado da consulta, e s√£o elas: driver_type, driver_modal, total_entregas, entregas_sucesso, taxa_sucesso_percentual e distancia_media_metros. Para isso, utilizei um LEFT JOIN entre as tabelas tb_act_drivers e tb_act_deliveries, unindo ambas pela chave prim√°ria driver_id. A op√ß√£o pelo LEFT JOIN foi intencional, pois garante que todos os entregadores sejam inclu√≠dos no resultado, mesmo aqueles que n√£o realizaram entregas, o que pode indicar inatividade ou baixa demanda.

```
create view vw_freelance_analise as
        select 
        	t1.driver_type,
        	t1.driver_modal,
        	count(t2.delivery_id) as total_entregas,
        	sum(case when t2.delivery_status = 'DELIVERED' then 1 else 0 end) as entregas_sucesso,
        	format(cast(sum(case when t2.delivery_status = 'DELIVERED' then 1 else 0 end) as float) / count(*) * 100, 'N2', 'PT-BR') as taxa_sucesso_percentual,
        	AVG(t2.delivery_distance_meters) as distancia_media_metros -- distancia media por tipo de modal 
        from [dbo].[tb_act_drivers] as t1
        
        left join [dbo].[tb_act_deliveries] as t2
        on t1.driver_id = t2.driver_id
        
        group by t1.driver_type, t1.driver_modal 
```

Em seguida, utilizei a fun√ß√£o COUNT() para contabilizar o total de entregas por tipo e modal de entregador. Para somar apenas as entregas com status ‚ÄúDELIVERED‚Äù, utilizei a fun√ß√£o SUM() combinada com a cl√°usula CASE WHEN. Isso permitiu filtrar apenas os registros bem-sucedidos e calcular, posteriormente, a taxa de sucesso percentual. Para formatar esse percentual com duas casas decimais e nota√ß√£o brasileira, apliquei a fun√ß√£o FORMAT() com os par√¢metros ‚ÄòN2‚Äô e ‚ÄòPT-BR‚Äô.

Abaixo, destaco um trecho da consulta SQL desenvolvida para responder √† pergunta:

Constata-se que tamb√©m inclu√≠ a m√©dia da dist√¢ncia percorrida em metros (delivery_distance_meters) por tipo de entregador e modal, por meio da fun√ß√£o AVG(). Essa m√©trica √© √∫til para entender se o desempenho est√° relacionado √† complexidade log√≠stica das rotas.

Agrupei os resultados pelas vari√°veis driver_type e driver_modal, o que permite cruzar o tipo de entregador com o modal log√≠stico (como bicicleta, moto, etc.) e observar padr√µes mais espec√≠ficos.

#### Resposta 1

A an√°lise dos dados revelou que tanto os entregadores freelancers quanto os operadores log√≠sticos apresentam taxas de sucesso nas entregas extremamente altas, todas superiores a 99,8%, o que indica um desempenho operacional bastante consistente.

<div align="center">
<img width="703" height="127" alt="Image" src="https://github.com/user-attachments/assets/214c61b0-c973-4abe-aa85-0284b025c956" />
</div>


Ao segmentar os resultados por tipo de modal, observamos que os freelancers bikers alcan√ßaram uma taxa de sucesso de 99,94%, com um total de 97.500 entregas realizadas. J√° os freelancers motoboys, embora com uma taxa ligeiramente inferior (99,81%), concentraram o maior volume de entregas entre todos os perfis analisados, somando mais de 161 mil.

No grupo dos operadores log√≠sticos, os motoboys tamb√©m apresentaram desempenho elevado, com 99,94% de entregas bem-sucedidas em um universo de mais de 103 mil registros. Por outro lado, os operadores bikers registraram taxa de sucesso de 100%, mas com uma amostra muito pequena (apenas 14 entregas), o que limita a confiabilidade dessa informa√ß√£o para tomada de decis√£o.

A m√©dia de dist√¢ncia percorrida tamb√©m trouxe insights relevantes. Os modais motoboy, tanto entre freelancers quanto entre operadores, apresentaram as maiores m√©dias de deslocamento (3.179 e 3.863 metros, respectivamente), sugerindo que esse perfil √© priorizado em rotas mais longas. J√° os bikers, com dist√¢ncias m√©dias bem inferiores (1.108 metros para freelancers e 2.326 metros para operadores), parecem atuar majoritariamente em regi√µes mais pr√≥ximas dos hubs de distribui√ß√£o.

Com base nesses dados, √© poss√≠vel concluir que n√£o h√° diferen√ßa significativa entre freelancers e operadores em termos de taxa de sucesso. No entanto, a distribui√ß√£o dos modais log√≠sticos evidencia uma estrat√©gia operacional que reserva os motoboys para dist√¢ncias maiores e os bikers para entregas mais locais. Esses resultados podem orientar decis√µes relacionadas √† aloca√ß√£o de entregadores, defini√ß√£o de √°reas de cobertura, e estrat√©gias de otimiza√ß√£o de custo e tempo de entrega.

### Pergunta, Descri√ß√£o e Resposta 2
#### Quest√£o 2

O modal log√≠stico (motoboy x motociclista) impacta o valor m√©dio dos pedidos?

#### Descri√ß√£o 2

Neste estudo, o objetivo foi investigar se os modais log√≠sticos mais r√°pidos tendem a operar com pedidos de maior valor. Para isso, precisei das colunas driver_modal, total_entregas, valor_medio_pedidos e distancia_media_metros, utilizando dados de tr√™s tabelas: tb_act_drivers, tb_act_deliveries e tb_act_orders. Como essas informa√ß√µes est√£o distribu√≠das entre diferentes tabelas, realizei as jun√ß√µes necess√°rias para consolidar os dados.

Para organizar a consulta e facilitar a compreens√£o, utilizei CTEs (Common Table Expressions), que s√£o express√µes tempor√°rias nomeadas que funcionam como tabelas virtuais dentro da execu√ß√£o da query. As CTEs permitem dividir consultas complexas em blocos mais leg√≠veis e reutiliz√°veis.

A primeira CTE, chamada modal, calcula o total de entregas, o valor m√©dio dos pedidos e a dist√¢ncia m√©dia percorrida, agrupando os dados por tipo de entregador e modal log√≠stico.

```
  create view vw_modal as 
             with modal as (
             
             select
             	t1.driver_type,
             	t1.driver_modal,
             	count(t2.delivery_id) as total_entregas,
             	avg(t3.order_amount) as valor_medio_pedidos,
             	avg(t2.delivery_distance_meters) AS distancia_media_metros
             from [dbo].[tb_act_drivers] as t1
             
             left join [dbo].[tb_act_deliveries] as t2
             on t1.driver_id = t2.driver_id
             
             left join [dbo].[tb_act_orders] as t3
             on t2.delivery_order_id = t3.delivery_order_id
             
             group by t1.driver_type, t1.driver_modal
             ), 

             analise_faixa_distancia as (
             
             select
             	t1.driver_modal,
             case
             	when t2.delivery_distance_meters <= 1000 then '0-1 km'
             	when t2.delivery_distance_meters > 1000 and t2.delivery_distance_meters <= 3000 then '1-3 km'
             	when t2.delivery_distance_meters > 3000 and t2.delivery_distance_meters <= 5000 then '3-5 km'
             	when t2.delivery_distance_meters > 5000 and t2.delivery_distance_meters <= 10000 then '5-10 km'
             	else '10 km+'
             	end as faixa_distancia,
             	count(delivery_id) as total_entregas,
             	AVG(t3.order_amount) as valor_medio_pedidos_faixa
             from [dbo].[tb_act_drivers] as t1
             
               left join [dbo].[tb_act_deliveries] as t2
                 on t1.driver_id = t2.driver_id
             
             
             	left join [dbo].[tb_act_orders] as t3
             		on t2.delivery_order_id = t3.delivery_order_id
             
             group by t1.driver_modal,
             
             case
             	when t2.delivery_distance_meters <= 1000 then '0-1 km'
             	when t2.delivery_distance_meters > 1000 and t2.delivery_distance_meters <= 3000 then '1-3 km'
             	when t2.delivery_distance_meters > 3000 and t2.delivery_distance_meters <= 5000 then '3-5 km'
             	when t2.delivery_distance_meters > 5000 and t2.delivery_distance_meters <= 10000 then '5-10 km'
             	else '10 km+'
             	end
             )
             
             SELECT 
    modal.driver_type,
    modal.driver_modal,
    modal.total_entregas AS total_entregas_modal,
    modal.valor_medio_pedidos,
    modal.distancia_media_metros,
    analise_faixa_distancia.faixa_distancia,
    analise_faixa_distancia.total_entregas AS total_entregas_faixa,
    ROUND(analise_faixa_distancia.valor_medio_pedidos_faixa, 2) AS valor_medio_pedidos_faixa
FROM modal
LEFT JOIN analise_faixa_distancia
    ON modal.driver_modal = analise_faixa_distancia.driver_modal



	select
		*
	from vw_modal

```



J√° a segunda CTE, analise_faixa_distancia, segmenta as entregas em faixas de dist√¢ncia pr√©-definidas (de 0‚Äì1 km at√© mais de 10 km), permitindo analisar como o valor m√©dio dos pedidos varia conforme o modal e a dist√¢ncia percorrida.

Essa estrutura modular com CTEs torna a an√°lise mais clara, possibilitando uma melhor organiza√ß√£o l√≥gica dos passos do processamento dos dados.

Por fim, selecionei as vari√°veis relevantes da CTE analise_faixa_distancia e ordenei os resultados por modal e faixa de dist√¢ncia, facilitando a interpreta√ß√£o dos dados.


#### Resposta 2

A an√°lise dos dados revelou padr√µes interessantes sobre a rela√ß√£o entre o modal log√≠stico, a dist√¢ncia percorrida e o valor m√©dio dos pedidos entregues. Observamos que, para ambos os modais analisados (bikers e motoboys), o valor m√©dio dos pedidos tende a aumentar conforme a dist√¢ncia da entrega se eleva.

<div align="center">
<img width="427" height="235" alt="Image" src="https://github.com/user-attachments/assets/ebdfe01d-d6b1-4679-b9af-33cd80a14561" />
</div>


No caso dos bikers, o maior volume de entregas concentra-se nas faixas de dist√¢ncia at√© 3 km, com valores m√©dios de pedido entre R$85,15 e R$90,14. Entretanto, em dist√¢ncias maiores, embora o n√∫mero de entregas diminua consideravelmente, o valor m√©dio dos pedidos cresce de forma significativa, chegando a R$194,54 para entregas acima de 10 km. Isso indica que, mesmo com menos frequ√™ncia, pedidos mais caros s√£o realizados em rotas mais longas por bikers.

Para os motoboys, o padr√£o √© semelhante, por√©m com volumes muito superiores de entregas em todas as faixas, destacando-se especialmente a faixa de 1 a 3 km, que concentra 130 mil entregas. O valor m√©dio dos pedidos para motoboys tamb√©m cresce conforme a dist√¢ncia, atingindo R$176,53 para entregas acima de 10 km e at√© R$140,10 na faixa de 5 a 10 km, o que √© ainda mais expressivo do que o observado para bikers em faixas similares.

Do ponto de vista de neg√≥cios, esses resultados sugerem que os modais mais r√°pidos, como os motoboys, s√£o utilizados para atender a uma maior demanda, especialmente em dist√¢ncias intermedi√°rias, com um ticket m√©dio crescente conforme a complexidade log√≠stica aumenta. J√° os bikers atuam predominantemente em dist√¢ncias curtas e m√©dias, com pedidos de menor valor m√©dio, exceto nos poucos casos de entregas longas, onde o valor sobe significativamente.

Essa compreens√£o pode ajudar a empresa a otimizar a aloca√ß√£o dos modais log√≠sticos, priorizando motoboys para rotas mais longas e para pedidos de maior valor, garantindo agilidade e efici√™ncia, enquanto os bikers podem focar em entregas locais, onde a rapidez e a agilidade tamb√©m s√£o importantes, mas com menor custo operacional.

Al√©m disso, o entendimento detalhado do ticket m√©dio por faixa de dist√¢ncia pode auxiliar na defini√ß√£o de pol√≠ticas comerciais e estrat√©gias de precifica√ß√£o, promovendo a maximiza√ß√£o da receita e a melhoria da experi√™ncia do cliente.

### Pergunta, Descri√ß√£o e Resposta 3
#### Quest√£o 3

Quais estados concentram os maiores volumes de pedidos e menores percentuais de desconto?

#### Descri√ß√£o 3

O foco da an√°lise √© relacionar o desempenho de vendas com a localiza√ß√£o do hub, usando as vari√°veis estado do hub, status do pedido, valor do pedido, valor do pagamento e status do pagamento.

Primeiro, selecionei as colunas cruciais para o resultado final: o estado do hub, o total de pedidos finalizados, a receita bruta (soma do valor dos pedidos), a receita l√≠quida (soma dos pagamentos efetivamente realizados) e o desconto m√©dio aplicado. Para isso, realizei joins entre as tabelas de hubs, lojas, pedidos e pagamentos, utilizando as chaves prim√°rias e estrangeiras correspondentes para garantir a integridade dos dados.

```
create view vw_uf_pedidos as
        select
        	t1.hub_state,
        	count(t3.order_id) as 'total pedidos',
        	format(round(sum(cast(t3.order_amount as float)), 2), 'N2', 'pt-BR') as 'receita bruta', 
        	format(round(sum(t4.payment_amount), 2), 'N2', 'pt-BR') as 'receita liquida',  
        	format(round(avg(
        		case
        			when t4.payment_amount <= try_cast(t3.order_amount as float) and try_cast(t3.order_amount as float) > 0 -- try_cast as float para converter um 
        			-- tipo especifico retornando null se a conversao falhar 
        				then 1.0 - (t4.payment_amount /  try_cast(t3.order_amount as float)) 
        				end ), 2) * 100, 'N2', 'pt-BR') as 'desconto medio'
        from [dbo].[tb_act_hubs] as t1
        
        left join [dbo].[tb_act_stores] as t2
        on t1.hub_id = t2.hub_id
        
        left join [dbo].[orders] as t3
        on t2.store_id = t3.store_id
        
        left join [dbo].[tb_act_payments] as t4
        on t3.payment_order_id = t4.payment_order_id
        
        where t3.order_status = 'FINISHED' and t4.payment_status = 'paid' -- pedidos e pagamentos finalizados 
        
        group by t1.hub_state

```

Utilizei a cl√°usula WHERE para filtrar apenas os pedidos com status ‚ÄúFINISHED‚Äù e pagamentos com status ‚Äúpaid‚Äù, garantindo que a an√°lise considere somente transa√ß√µes conclu√≠das e efetivamente pagas.

Para calcular o desconto m√©dio, utilizei uma express√£o condicional que compara o valor pago com o valor do pedido, computando a diferen√ßa percentual apenas quando o pagamento foi menor que o pedido e o valor do pedido √© v√°lido, o que evita distor√ß√µes. A m√©dia desse percentual foi arredondada e formatada para exibir com duas casas decimais e em nota√ß√£o brasileira.

O agrupamento foi feito pelo estado do hub, permitindo identificar quais regi√µes apresentam maior volume de pedidos, maior receita e melhor margem (menor desconto m√©dio).

#### Resposta 3

A an√°lise do desempenho dos hubs em diferentes estados revela informa√ß√µes estrat√©gicas valiosas para o neg√≥cio.

<div align="center">
<img width="441" height="121" alt="Image" src="https://github.com/user-attachments/assets/14d89f6d-daef-4656-a032-84986d7bbf15" />
</div>


Observamos que o estado de S√£o Paulo (SP) lidera em volume de pedidos, com 179.174 pedidos finalizados, gerando uma receita bruta de aproximadamente R$ 19,89 milh√µes e receita l√≠quida pr√≥xima a R$ 19,67 milh√µes. O desconto m√©dio aplicado nas vendas em SP √© de 24%.

O Rio Grande do Sul (RS), embora com um volume menor de pedidos (40.215), apresenta um desconto m√©dio mais elevado, de 31%. Isso pode indicar uma estrat√©gia comercial mais agressiva para atrair clientes ou poss√≠veis desafios de efici√™ncia log√≠stica e convers√£o que impactam a rentabilidade. A receita l√≠quida de RS (R$ 2,99 milh√µes) representa cerca de 90% da receita bruta.

No Paran√° (PR), o volume de pedidos √© menor, com 33.584 transa√ß√µes, mas o desconto m√©dio √© o menor entre os estados analisados, em 20%. Esse menor percentual de desconto aliado a uma receita l√≠quida de R$ 1,98 milh√£o em rela√ß√£o a uma receita bruta de R$ 2,25 milh√µes.

J√° o Rio de Janeiro (RJ) mostra um volume expressivo de pedidos, 147.401, com receita bruta de R$ 12,86 milh√µes e receita l√≠quida de R$ 12,66 milh√µes, e um desconto m√©dio de 26%.

Do ponto de vista estrat√©gico, esses resultados indicam que os hubs em estados como SP e RJ representam mercados maduros com alto volume e boa rentabilidade, merecendo aten√ß√£o para investimentos e expans√£o. Em contrapartida, estados como RS, com descontos mais elevados, podem demandar a√ß√µes espec√≠ficas para otimizar margens e melhorar a efici√™ncia comercial. O PR surge como um estado com potencial para crescimento sustent√°vel, dada a baixa taxa de desconto e margens mais favor√°veis.

Essas an√°lises s√£o fundamentais para direcionar esfor√ßos comerciais e log√≠sticos, ajustar pol√≠ticas de pre√ßo e desconto, e planejar expans√µes geogr√°ficas de forma inteligente, focando em rentabilidade e competitividade do neg√≥cio.

### Conclus√£o

Este projeto pr√°tico consolidou meu aprendizado em SQL e refor√ßou a import√¢ncia de dominar a linguagem para atuar como analista de dados. Ao longo da an√°lise, utilizei comandos essenciais como JOIN, GROUP BY, CASE WHEN, AVG, SUM, FORMAT, e t√©cnicas mais avan√ßadas como o uso de CTEs (Common Table Expressions), que tornaram as consultas mais organizadas e leg√≠veis, especialmente em an√°lises segmentadas por faixas ou categorias.

Al√©m disso, interpretei os resultados sempre com uma perspectiva de neg√≥cios, identificando padr√µes relevantes de comportamento log√≠stico, desempenho comercial por regi√£o e rela√ß√£o entre dist√¢ncia e ticket m√©dio. Isso mostra como SQL vai al√©m da manipula√ß√£o de dados, ele √© uma ferramenta poderosa para extra√ß√£o de insights estrat√©gicos.




## Brazilian Ecommerce

### Contexto e explica√ß√£o do problema

Como parte do meu processo de aprendizado cont√≠nuo em SQL, conclu√≠ recentemente esta segunda atividade pr√°tica de an√°lise de dados, desta vez utilizando um conjunto de dados do com√©rcio eletr√¥nico brasileiro, disponibilizado pela Olist na plataforma Kaggle e discutido em um curso de SQL.

Esta base √© composta por mais de 100 mil pedidos realizados entre 2016 e 2018, abrangendo diversas dimens√µes relevantes do e-commerce: status do pedido, forma de pagamento, valor do frete, localiza√ß√£o do cliente, caracter√≠sticas do produto e avalia√ß√µes p√≥s-compra. Al√©m disso, o conjunto inclui dados de geolocaliza√ß√£o.

Para essa pr√°tica, mantive a escolha do SQL Server como sistema de gerenciamento de banco de dados, devido √† sua vasta documenta√ß√£o e √† ampla base de usu√°rios, fatores que contribuem bastante na resolu√ß√£o de d√∫vidas ao longo do desenvolvimento. Tamb√©m considerei, como crit√©rios para a escolha do conjunto de dados, a exist√™ncia de diversas tabelas com colunas em comum, um volume de dados representativo, capaz de sustentar an√°lises mais robustas, e a possibilidade de realizar diferentes tipos de jun√ß√µes e filtros, colocando em pr√°tica os principais recursos da linguagem SQL.

A inten√ß√£o, com este segundo portf√≥lio, foi seguir consolidando meu dom√≠nio da linguagem SQL e a capacidade de elaborar consultas anal√≠ticas mais estruturadas.

Em breve, pretendo complementar esse trabalho com visualiza√ß√µes interativas e dashboards no Power BI, trazendo uma perspectiva mais visual e executiva para os insights obtidos a partir dos dados. Tamb√©m ser√° poss√≠vel expandir as an√°lises estat√≠sticas robustas com o uso da linguagem R, aproveitando os conhecimentos adquiridos na p√≥s-gradua√ß√£o stricto sensu.

Para acessar o primeiro portf√≥lio, no qual desenvolvi consultas SQL baseadas em an√°lises comparativas e explorat√≥rias de dados de delivery, integrando m√∫ltiplas tabelas com foco em entregas, modais log√≠sticos, valores m√©dios de pedidos e desempenho regional, clique aqui. As consultas envolveram jun√ß√µes (joins), agrega√ß√µes (contagem, soma, m√©dia), filtros por status e segmenta√ß√µes por faixas de dist√¢ncia, tipo de entregador e regi√£o. Al√©m disso, utilizei CTEs para estruturar a l√≥gica das queries, garantindo organiza√ß√£o e clareza no processamento dos dados.

### Vamos ao assunto principal:

Neste projeto, utilizo o banco de dados Olist, que cont√©m oito tabelas principais, algumas a serem usadas para responder √†s perguntas propostas. Abaixo, segue a descri√ß√£o de cada uma:

- olist customers cont√©m informa√ß√µes sobre os clientes e sua localiza√ß√£o. Permite identificar clientes √∫nicos no conjunto de pedidos e localizar os destinos das entregas. Cada pedido tem um customer ID exclusivo, mas o customer unique ID permite reconhecer clientes que fizeram m√∫ltiplas compras.
- olist_geolocation: re√∫ne dados sobre c√≥digos postais brasileiros e suas coordenadas de latitude e longitude. Utilizado para mapear locais e calcular dist√¢ncias entre vendedores e clientes.
- olist_order_items: cont√©m dados dos itens comprados em cada pedido.
- olist_order_payments: inclui informa√ß√µes sobre as formas de pagamento usadas em cada pedido.
- olist_order_reviews: traz avalia√ß√µes e coment√°rios dos clientes, enviados ap√≥s a entrega, para registrar a satisfa√ß√£o com a compra.
- olist_orders: √© o conjunto de dados principal, onde cada pedido pode ser associado a todas as outras informa√ß√µes das tabelas relacionadas.
- olist_products: re√∫ne dados sobre os produtos vendidos na plataforma.
- olist_sellers: cont√©m informa√ß√µes sobre os vendedores que atenderam aos pedidos, incluindo sua localiza√ß√£o e associa√ß√£o a cada produto vendido.
- 
Aqui est√° a figura disponibilizada pelo autor do modelo de dados.

<img width="2486" height="1496" alt="Image" src="https://github.com/user-attachments/assets/341040f0-dbc3-4566-8689-cbd4ce79d770" />
Imagem 1: Explica√ß√£o da tabela. Fonte: https://www.kaggle.com/datasets/olistbr/brazilian-ecommerce?select=product_category_name_translation.csv

As perguntas e as respostas

A seguir, apresento as tr√™s perguntas que devem ser respondidas utilizando algumas das tabelas mencionadas acima. Em cada item, trarei a pergunta, a descri√ß√£o e, em seguida, a respectiva resposta.

### Pergunta, Descri√ß√£o e Resposta 1
#### Quest√£o 1

Qual √© o produto mais comprado por cliente e por vendedor, considerando a categoria do produto, a quantidade de vendas e o valor total vendido, al√©m de quantas compras cada cliente realizou e quanto gastou no total?

#### Descri√ß√£o 1

A partir da pergunta ‚ÄúQual √© o produto mais comprado por cliente, considerando a categoria, a quantidade e o valor total gasto?‚Äù, defini que as colunas necess√°rias no resultado da consulta seriam: customer unique ID, product category name, quantidade (quantidade de compras da categoria) e valor total (soma dos pre√ßos dos produtos dessa categoria).

Para isso, utilizei uma CTE (Common Table Expression) chamada customers, que faz a jun√ß√£o das tabelas clientes, pedidos, itens do pedido e produtos, usando as chaves customer ID, order ID e product ID, respectivamente. Essa jun√ß√£o foi feita com LEFT JOIN, garantindo que todos os clientes sejam considerados, mesmo aqueles com compras incompletas ou com produtos sem categoria definida.

Nessa etapa, apliquei a fun√ß√£o COUNT() para contar quantas vezes o cliente comprou produtos de uma determinada categoria, e SUM() para calcular o valor total gasto nessas compras.


```
create view vw_produto_mais_comprado_por_cliente
as


with customers as (
   select
   		t1.customer_unique_id,
		t4.product_category_name,
   		count(t2.order_id) as qntd,
		sum(t3.price) as valor_total
   from [dbo].[tb_act_olist_customers_dataset] as t1
   
   left join [dbo].[tb_act_olist_orders] as t2
on t1.customer_id = t2. customer_id

	left join [dbo].[tb_act_olist_order_items] as t3
	on t2.order_id = t3.order_id

	left join [dbo].[tb_act_olist_products] as t4
	on t3.product_id = t4.product_id

group by t1.customer_unique_id, t4.product_category_name


),

rankeamento as (
-- rankear pra saber quais dos produtos ele comprou mais vezes: quais produtos foram mais vendidos

select
	*,
	row_number() over(partition by customer_unique_id order by qntd desc, valor_total desc) as rank
from customers 

)
-- filtrar so quem tem ranking = 1
select
	*
from rankeamento 

where rank = 1

```

Em seguida, criei uma segunda CTE chamada rankeamento, onde utilizei a fun√ß√£o ROW_NUMBER() com PARTITION BY por customer unique ID e ordena√ß√£o por quantidade em ordem decrescente e valor total em ordem decrescente. Isso permite identificar, para cada cliente, qual foi a categoria de produto mais comprada, priorizando a quantidade e, em caso de empate, o valor total gasto.

Por fim, selecionei apenas os registros com rank igual a 1, ou seja, a categoria mais comprada por cada cliente, tanto em volume quanto em valor. Isso permite obter insights sobre os h√°bitos de consumo dos clientes e pode ser utilizado para estrat√©gias de personaliza√ß√£o, recomenda√ß√£o de produtos ou campanhas de fideliza√ß√£o.

A consulta foi salva como uma view chamada vw_produto_mais_comprado_por_cliente, facilitando o reuso em an√°lises futuras.


Resposta 1

A an√°lise teve como objetivo identificar a quantidade de compras realizadas por cada cliente, por meio da contagem do n√∫mero de pedidos registrados na tabela Orders. Al√©m disso, buscou-se calcular o valor total gasto por cada um desses clientes, somando os pre√ßos dos produtos presentes em cada pedido, com base nos dados da tabela Order Items. Dessa forma, foi poss√≠vel mapear o comportamento de compra individual, considerando tanto a frequ√™ncia quanto o volume financeiro das transa√ß√µes.

<div align="center">
<img width="545" height="776" alt="Image" src="https://github.com/user-attachments/assets/4736b697-4e63-4f57-8add-c76d318e1d87" />
</div>



### Pergunta, Descri√ß√£o e Resposta 2
#### Quest√£o 2

Qual √© o valor total de vendas (considerando pre√ßo e frete) realizado por cada vendedor, discriminado por tipo de pagamento (cart√£o, boleto ou voucher), e qual o percentual que cada forma de pagamento representa no total de vendas de cada vendedor?

#### Descri√ß√£o 2

Nessa quest√£o, o objetivo foi analisar o comportamento de vendas por tipo de pagamento (cart√£o de cr√©dito, boleto, voucher e cart√£o de d√©bito) para cada vendedor da base, identificando o valor total vendido e o percentual correspondente de cada m√©todo de pagamento. Para isso, foram utilizadas as tabelas Order Items e Order Payments.

Como os dados de vendas e pagamentos est√£o distribu√≠dos entre diferentes tabelas, organizei a consulta utilizando CTEs (Common Table Expressions), que permitem estruturar consultas complexas de forma mais leg√≠vel.

A primeira CTE, chamada Sellers, agrega o valor total de vendas de cada pedido por vendedor, somando os campos price e freight_value (pre√ßo do item e valor do frete).

```
create view vw_tipo_pagamento_por_vendedor
as 

-- 3) vendas por tipo de cada vendedor - cartao, boleto ou voucher 


-- informa√ß√£o de todos os vendedores (seller_id), o valor total d evendas de cada um desses vendedores, percentual de acordo com o tipo de pagamento 


-- informacao dos vendedores e do tipo de pagamento 

-- valor total: pre√ßo + frete


with sellers as (

select
	seller_id,
	order_id,
	sum(price + freight_value) as valor_total
from [dbo].[tb_act_olist_order_items] as t1

group by seller_id, order_id

),

tipo_pagamento as (

select
	order_id,
	payment_type,
	sum(payment_value) as valor_pago
from [dbo].[tb_act_olist_order_payments] 

group by order_id, payment_type 


),

cruzamento as (

select
	t1.seller_id,
	t1.valor_total,
	t2.payment_type
from sellers as t1

left join tipo_pagamento as t2
on t1.order_id = t2.order_id

),

tratamento as (

-- eu quero uma so linha pra cada vendedor 
select
	seller_id,
	sum(valor_total) as valor_total,
	sum(case when payment_type = 'credit_card' then valor_total else 0 end) as cartao_credito,
	sum(case when payment_type = 'boleto' then valor_total else 0 end) as boleto,
	sum(case when payment_type = 'voucher' then valor_total else 0 end) as voucher,
	sum(case when payment_type = 'debit_card' then valor_total else 0 end) as cartao_debito
from cruzamento 

group by seller_id


-- ainda nao ta agrupando por vendedor 

)

select 
	seller_id,
	sum(valor_total) as valor_total,
	sum(cartao_credito) as cartao_credito,
	sum(boleto) as boleto,
	sum(voucher) as voucher,
	sum(cartao_debito) as cartao_debito
from tratamento 

group by seller_id
-- qual foi o tipo de pagamento por seller_id


-- ########################################################33


select 
	*
from vw_tipo_pagamento_por_vendedor


```

Em seguida, a CTE Tipo Pagamento calcula o valor total pago por pedido e por tipo de pagamento (como cr√©dito, boleto ou voucher), agrupando os dados com base no order_id.


Na CTE Cruzamento, foi realizada uma jun√ß√£o entre essas duas fontes de informa√ß√£o (vendedores e pagamentos), conectando as CTEs anteriores por order_id e associando cada venda ao tipo de pagamento utilizado.


A CTE Tratamento consolida os dados por vendedor, somando os valores totais e discriminando quanto foi pago com cada forma de pagamento, por meio da fun√ß√£o CASE WHEN.


Por fim, a query final seleciona os dados de cada vendedor, exibindo o valor total vendido e os valores separados por tipo de pagamento, permitindo observar com clareza o perfil de pagamento dos clientes de cada vendedor.


Essa estrutura com CTEs facilita a leitura da consulta, al√©m de permitir a reutiliza√ß√£o dos dados intermedi√°rios para novas an√°lises. O resultado pode ser usado para entender prefer√™ncias de pagamento por vendedor e apoiar estrat√©gias comerciais ou financeiras.


Resposta 2

Nesta quest√£o, o objetivo foi analisar o desempenho de vendas dos vendedores considerando os diferentes tipos de pagamento utilizados pelos clientes. Para isso, foram consolidadas informa√ß√µes de todos os vendedores (identificados por seller_id), detalhando o valor total de vendas de cada um, calculado como a soma do pre√ßo dos produtos com o valor do frete.

<div align="center">
<img width="590" height="795" alt="Image" src="https://github.com/user-attachments/assets/cbf6448b-b8ff-4650-9f97-9075ace5a3db" />
</div>


Al√©m disso, as vendas foram segmentadas de acordo com o tipo de pagamento utilizado, como cart√£o de cr√©dito, boleto, voucher e cart√£o de d√©bito. Essa estrutura permite compreender n√£o apenas quanto cada vendedor faturou, mas tamb√©m qual foi a distribui√ß√£o percentual de seus recebimentos por tipo de pagamento, oferecendo uma vis√£o mais completa sobre o comportamento de consumo e a depend√™ncia de cada vendedor em rela√ß√£o aos meios de pagamento.

### Pergunta, Descri√ß√£o e Resposta 3
#### Quest√£o 3

Quais s√£o os percentuais de vendas por categoria para cada vendedor na base de dados, e como essas distribui√ß√µes podem ajudar a identificar o foco comercial de cada vendedor?

#### Descri√ß√£o 3

O objetivo dessa an√°lise foi identificar o percentual de vendas por categoria para cada vendedor, relacionando o valor total vendido em categorias espec√≠ficas, como alimentos, constru√ß√£o, eletrodom√©sticos, fashion, livros, m√≥veis, telefonia e outros.

Inicialmente, selecionei as informa√ß√µes de vendas dos vendedores e dos produtos, utilizando as tabelas tb_act_olist_order_items e tb_act_olist_products para relacionar cada venda com sua respectiva categoria. Realizei a jun√ß√£o entre essas tabelas com base na coluna product_id, garantindo a correspond√™ncia correta.

Para organizar a an√°lise, utilizei Common Table Expressions (CTEs) que facilitaram o c√°lculo dos valores totais vendidos por vendedor e categoria, a transforma√ß√£o das categorias em colunas espec√≠ficas, o c√°lculo do valor total vendido por vendedor e, por fim, o c√°lculo do percentual que cada categoria representa no total de vendas do vendedor.

A primeira CTE, chamada sellers, calcula o valor total vendido por cada vendedor em cada categoria de produto. Para isso, ela faz um join entre a tabela de itens vendidos e a tabela de produtos para associar o produto √† sua categoria, removendo espa√ßos extras nos IDs para garantir a correspond√™ncia correta. Em seguida, agrupa os dados por vendedor e categoria, somando o valor total das vendas (pre√ßo mais valor do frete) para cada combina√ß√£o.

```
create view vw_percentual_categorias_por_vendedor
as 

-- 1) percentual de categorias mais vendidas por vendedor 


-- 1. CTE 'sellers': calcula o valor total vendido por vendedor e categoria


with sellers as (

	SELECT
    t1.seller_id,
    t2.product_category_name,
    SUM(t1.price + t1.freight_value) AS valor_total
FROM tb_act_olist_order_items t1
LEFT JOIN tb_act_olist_products t2
    ON LTRIM(RTRIM(t1.product_id)) = LTRIM(RTRIM(t2.product_id)) -- remove espa√ßos a direita e a esquerda 
GROUP BY t1.seller_id, t2.product_category_name



-- tb_act_olist_order_items - informacao dos vendedores 
-- tenho o seller_id e o valor total. Pq o valor total? 
-- percentual: o valor vendido em construcao dividido pelo valor total, por ex 

-- tabela que tem as categorias: [dbo].[tb_act_olist_products]

-- uma linha para o vendedor de venda em cada categoria - granuralidade diferentes 

),

-- 2. CTE 'tratamento': transforma as categorias em colunas espec√≠ficas

tratamento as (

-- categorizar as categorias que precisam e o valor de venda d ecada uma dessas categorias por vendedor 

select
	seller_id,
	sum(case when product_category_name like '%alimentos%' then valor_total else 0 end) as alimentos, 
	sum(case when product_category_name like '%construcao%' then valor_total else 0 end) as construcao, 
	sum(case when product_category_name like '%eletrodomesticos%' then valor_total else 0 end) as eletrodomesticos, 
	sum(case when product_category_name like '%fashion%' then valor_total else 0 end) as fashion, 
	sum(case when product_category_name like '%livros%' then valor_total else 0 end) as livros, 
	sum(case when product_category_name like '%moveis%' then valor_total else 0 end) as moveis, 
	sum(case when product_category_name like '%telefonia%' then valor_total else 0 end) as telefonia,
	sum(case when product_category_name not like '%alimentos%'
		and product_category_name not like '%construcao%'
		and product_category_name not like '%eletrodomesticos%'
		and product_category_name not like '%fashion%'
		and product_category_name not like '%livros%'
		and product_category_name not like '%moveis%'
		and product_category_name not like '%telefonia%'
then valor_total
else 0
end) as outros 
from sellers 

group by seller_id

),

-- 3. CTE 'valor_total': valor total vendido por vendedor


-- aqui eu tinha varias linhas para um unico vendedor 

valor_total as (

select 
	seller_id,
	sum(valor_total) as valor_total
from sellers

group by seller_id

),

-- 4. CTE 'percentual': calcula o percentual de vendas por categoria

percentual as (

-- quero uma linha pra cada vendedor 
-- preciso do percentual
-- independnete do produto, que conste em uma linha apenas 


select
	t1.seller_id,
	round((t1.alimentos / t2.valor_total) * 100, 2) as alimentos,
	round((t1.construcao / t2.valor_total) * 100 ,2) as construcao,
	round((t1.eletrodomesticos / t2.valor_total) * 100 ,2) as eletrodomesticos,
	round((t1.fashion / t2.valor_total) * 100 ,2) as fashion, 
	round((t1.livros / t2.valor_total) * 100 ,2) as livros, 
	round((t1.moveis / t2.valor_total) * 100 ,2) as moveis,
	round((t1.telefonia / t2.valor_total) * 100 ,2) as telefonia,
	round((t1.outros / t2.valor_total) * 100 ,2) as outros
from tratamento as t1

left join valor_total as t2
on t1.seller_id = t2.seller_id
```

A segunda CTE, denominada tratamento, transforma as categorias de produtos em colunas espec√≠ficas, criando uma vis√£o mais estruturada dos dados. Ela agrupa os valores totais vendidos por categoria para cada vendedor, utilizando express√µes condicionais (CASE WHEN) para alocar os valores em colunas como alimentos, constru√ß√£o, eletrodom√©sticos, fashion, livros, m√≥veis, telefonia, e uma coluna ‚Äúoutros‚Äù para categorias que n√£o se enquadram nas anteriores.


A terceira CTE, chamada valor_total, calcula o valor total vendido por cada vendedor, somando todas as categorias. Essa etapa √© importante para que, posteriormente, seja poss√≠vel calcular o percentual de participa√ß√£o de cada categoria no total vendido por vendedor.


Por fim, a quarta CTE, chamada percentual, calcula o percentual que cada categoria representa dentro do total vendido por cada vendedor. Para isso, realiza um join entre a tabela de valores por categoria e a tabela de valor total, dividindo o valor vendido em cada categoria pelo total do vendedor, multiplicando por 100 e arredondando o resultado para duas casas decimais. O resultado final apresenta, para cada vendedor, os percentuais de vendas distribu√≠dos por categoria, permitindo identificar o foco comercial de cada um.



#### Resposta 3

A estrutura dos dados permite identificar claramente quais categorias predominam em cada vendedor, facilitando a segmenta√ß√£o e direcionamento de estrat√©gias comerciais espec√≠ficas.

<div align="center">
<img width="729" height="783" alt="Image" src="https://github.com/user-attachments/assets/4140146a-1e3a-416a-9c29-2b421527a54b" />
</div>

### Conclus√£o

Este projeto pr√°tico aprofundou meu dom√≠nio em SQL, especialmente no uso de CTEs (Common Table Expressions) para estruturar consultas complexas de forma clara e eficiente. Ao longo da an√°lise, trabalhei com m√∫ltiplas tabelas relacionando clientes, vendedores, produtos, pagamentos e categorias, aplicando comandos essenciais como JOIN, GROUP BY, CASE WHEN, SUM e fun√ß√µes de ranking para responder perguntas comerciais relevantes.

Al√©m disso, a interpreta√ß√£o dos resultados sempre foi guiada por uma vis√£o de neg√≥cio, permitindo identificar o comportamento de compra dos clientes, o desempenho dos vendedores por forma de pagamento e o foco comercial por categoria de produto. Essas an√°lises mostram que o SQL n√£o √© apenas uma linguagem para manipula√ß√£o de dados, mas uma ferramenta fundamental para extrair insights estrat√©gicos que apoiam a tomada de decis√£o.






## Hospital Management

### Contexto e explica√ß√£o do problema

Tenho me dedicado a aprimorar meus conhecimentos em SQL e recentemente finalizei uma atividade pr√°tica focada em an√°lise de dados. J√° havia aprendido SQL de forma autodidata, complementando meu aprendizado com especializa√ß√µes. Essa pr√°tica compartilhada aqui refor√ßou ainda mais meu entendimento da linguagem e sua aplica√ß√£o pr√°tica.

Neste projeto, busquei responder a tr√™s perguntas a partir de um conjunto de dados estruturado, previamente baixado na plataforma Kaggle. Tive liberdade para escolher o sistema gerenciador de banco de dados (SGBD) e, ap√≥s testar tr√™s op√ß√µes (SQL Server, pgAdmin e PostgreSQL), optei por utilizar o SQL Server, principalmente pela maior disponibilidade de f√≥runs, documenta√ß√£o e materiais de apoio online. Apesar disso, o PostgreSQL me pareceu mais interessante por sua semelhan√ßa com o R, linguagem com a qual j√° tenho mais familiaridade.

A escolha do banco de dados considerou os seguintes crit√©rios:
[i] que houvesse mais de duas tabelas, j√° que um dos principais objetivos era praticar o uso de joins;
[ii] que existissem colunas em comum entre as tabelas para permitir a jun√ß√£o eficiente dos dados;
[iii] que o n√∫mero de linhas fosse suficientemente representativo para an√°lises mais robustas.

Al√©m da explora√ß√£o realizada com SQL, pretendo, em etapas futuras, complementar a an√°lise com visualiza√ß√µes interativas no Power BI. O objetivo √© transformar os resultados obtidos em dashboards din√¢micos que facilitem a interpreta√ß√£o e a comunica√ß√£o dos insights extra√≠dos.

Tamb√©m planejo aplicar t√©cnicas estat√≠sticas mais avan√ßadas, como regress√µes, utilizando a linguagem R, aproveitando os conhecimentos adquiridos durante a p√≥s-gradua√ß√£o stricto sensu.

Para acessar o primeiro portf√≥lio, no qual desenvolvi consultas SQL baseadas em an√°lises comparativas e explorat√≥rias de dados de delivery, integrando m√∫ltiplas tabelas com foco em entregas, modais log√≠sticos, valores m√©dios de pedidos e desempenho regional, clique aqui. As consultas envolveram jun√ß√µes (joins), agrega√ß√µes (contagem, soma, m√©dia), filtros por status e segmenta√ß√µes por faixas de dist√¢ncia, tipo de entregador e regi√£o. Al√©m disso, utilizei CTEs para estruturar a l√≥gica das queries, garantindo organiza√ß√£o e clareza no processamento dos dados.

Disponibilizo tamb√©m o segundo projeto, no qual utilizei o banco de dados Olist, composto por oito tabelas principais, para responder a perguntas estrat√©gicas sobre comportamento de clientes, desempenho de vendedores e an√°lise detalhada das vendas por categoria e tipo de pagamento. Por meio de consultas SQL estruturadas com CTEs, jun√ß√µes e agrega√ß√µes, explorei informa√ß√µes sobre clientes, produtos, pedidos, pagamentos e avalia√ß√µes, aprofundando a an√°lise dos dados de ecommerce para gerar insights comerciais relevantes.

### Vamos ao assunto principal:

Neste projeto, utilizo o banco de dados Hospital Management Dataset, que cont√©m cinco tabelas principais, utilizadas para responder √†s perguntas propostas. Abaixo, segue a descri√ß√£o de cada uma:

- atients.csv ‚Äî Dados demogr√°ficos, contatos, informa√ß√µes de registro e seguro dos pacientes;
- doctors.csv ‚Äî Perfis dos m√©dicos, especializa√ß√µes, experi√™ncia e contatos;
- appointments.csv ‚Äî Datas, hor√°rios, motivos das visitas e status dos agendamentos;
- treatments.csv ‚Äî Tipos de tratamento, descri√ß√µes, datas e custos associados;
- billing.csv ‚Äî Valores cobrados, formas de pagamento e status das transa√ß√µes.

#### As perguntas e as respostas

A seguir, apresento as tr√™s perguntas que devem ser respondidas utilizando algumas das tabelas mencionadas acima. Em cada item, trarei a pergunta, a descri√ß√£o e, em seguida, a respectiva resposta.

### Pergunta, Descri√ß√£o e Resposta 1
#### Quest√£o 1

Quais tipos de tratamento est√£o associados √†s maiores taxas de inadimpl√™ncia (pagamentos pendentes ou falhos)?

#### Descri√ß√£o 1

Para responder √† pergunta ‚ÄúCertos tipos de tratamento apresentam maior taxa de inadimpl√™ncia?‚Äù, iniciei a an√°lise construindo uma CTE chamada inadimplencia_por_tratamento. Nessa etapa, defini as colunas treatment_type, amount, total_tratamentos, inadimplentes e taxa_inadimplencia_percentual. A CTE realiza um LEFT JOIN entre as tabelas treatments (que cont√©m os registros dos procedimentos realizados) e billing (com as informa√ß√µes de faturamento), unindo-as pela chave prim√°ria treatment_id. O uso do LEFT JOIN foi intencional para garantir que todos os tratamentos fossem considerados, mesmo aqueles que ainda n√£o possu√≠am cobran√ßa registrada. Isso permite identificar poss√≠veis falhas ou atrasos no processo de faturamento.

Dentro dessa mesma CTE, utilizei a fun√ß√£o COUNT() para contabilizar o total de tratamentos por tipo (treatment_type). Em seguida, apliquei a fun√ß√£o SUM() combinada com CASE WHEN para somar os tratamentos cujo status de pagamento fosse ‚Äúpending‚Äù ou ‚Äúfailed‚Äù, considerados inadimplentes. A taxa de inadimpl√™ncia foi ent√£o calculada com base na propor√ß√£o desses casos em rela√ß√£o ao total de tratamentos, utilizando a f√≥rmula (inadimplentes / total_tratamentos) * 100 e formatada com duas casas decimais por meio da fun√ß√£o ROUND(). O uso do NULLIF() garante que divis√µes por zero sejam evitadas, retornando NULL nos casos em que o n√∫mero de tratamentos √© igual a zero.

```
CREATE VIEW vw_inadimplencia AS

WITH inadimplencia_por_tratamento AS (
    SELECT
        t1.treatment_type,
        t2.amount,
        COUNT(t1.treatment_id) AS total_tratamentos,
        SUM(CASE WHEN t2.payment_status IN ('pending', 'failed') THEN 1 ELSE 0 END) AS inadimplentes,
        CAST(ROUND(
            100.0 * SUM(CASE WHEN t2.payment_status IN ('pending', 'failed') THEN 1 ELSE 0 END) /
            NULLIF(COUNT(t1.treatment_id), 0), 2
        ) AS decimal(5,2)) as taxa_inadimplencia_percentual
    FROM [dbo].[treatments] t1
    LEFT JOIN [dbo].[billing] t2 ON t1.treatment_id = t2.treatment_id
    GROUP BY t1.treatment_type, t2.amount
)

SELECT
    treatment_type,
    CASE    
        WHEN TRY_CAST(amount AS decimal(18,2)) < 1000 THEN 'baixo (<1K)'
        WHEN TRY_CAST(amount AS decimal(18,2)) BETWEEN 1000 AND 3000 THEN 'medio (1K-3K)'
        ELSE 'alto (>3k)'
    END AS faixa_valor,
    SUM(total_tratamentos) AS total_tratamentos,
    SUM(inadimplentes) AS inadimplentes,
    ROUND(
        100.0 * SUM(inadimplentes) / NULLIF(SUM(total_tratamentos), 0), 2
    ) AS taxa_inadimplencia_percentual
FROM inadimplencia_por_tratamento
GROUP BY
    treatment_type,
    CASE    
        WHEN TRY_CAST(amount AS decimal(18,2)) < 1000 THEN 'baixo (<1K)'
        WHEN TRY_CAST(amount AS decimal(18,2)) BETWEEN 1000 AND 3000 THEN 'medio (1K-3K)'
        ELSE 'alto (>3k)'
    END

----------------------------------

ALTER VIEW vw_inadimplencia AS

WITH inadimplencia_por_tratamento AS (
    select
        t1.treatment_type,
        t2.amount,
        count(t1.treatment_id) as total_tratamentos,
        sum(case when t2.payment_status in ('pending', 'failed') then 1 else 0 end) as inadimplentes,
        cast(round(
            100.0 * sum(case when t2.payment_status in ('pending', 'failed') then 1 else 0 end) /
            nullif(count(t1.treatment_id), 0), 2
        ) as decimal(5,2)) as taxa_inadimplencia_percentual
    from [dbo].[treatments] t1
    left join [dbo].[billing] t2 on t1.treatment_id = t2.treatment_id
    group by t1.treatment_type, t2.amount
)

select
    treatment_type,
    case    
        when try_cast(amount as decimal(18,2)) < 1000 then 'baixo (<1K)'
        when try_cast(amount as decimal(18,2)) between 1000 and 3000 then 'medio (1K-3K)'
        else 'alto (>3k)'
    end as faixa_valor,
    sum(total_tratamentos) as total_tratamentos,
    sum(inadimplentes) as inadimplentes,
    cast(round(
        100.0 * sum(inadimplentes) / nullif(sum(total_tratamentos), 0), 2
    ) as decimal(5,2)) as taxa_inadimplencia_percentual
from inadimplencia_por_tratamento
group by
    treatment_type,
    case    
        when try_cast(amount as decimal(18,2)) < 1000 then 'baixo (<1K)'
        when try_cast(amount as decimal(18,2)) between 1000 and 3000 then 'medio (1K-3K)'
        else 'alto (>3k)'
    end



----------------------------------



	SELECT *
FROM vw_inadimplencia
ORDER BY taxa_inadimplencia_percentual DESC;
```

A segunda parte da consulta, fora da CTE, classifica os valores da coluna amount em tr√™s faixas de pre√ßo: baixo (<1K), m√©dio (1K‚Äì3K) e alto (>3K). Para isso, utilizei a fun√ß√£o TRY_CAST() para tentar converter os valores de amount para o tipo num√©rico DECIMAL(18,2). Essa fun√ß√£o √© preferida em vez do CAST() tradicional porque, caso o valor de amount seja inv√°lido (por exemplo, texto n√£o num√©rico), o TRY_CAST() retorna NULL em vez de gerar erro. Isso torna a consulta mais robusta e tolerante a dados sujos ou inconsistentes. Em seguida, utilizei a estrutura CASE para classificar os valores convertidos em faixas, o que permite segmentar a inadimpl√™ncia tamb√©m com base no custo dos tratamentos.


Por fim, os resultados foram ordenados de forma decrescente pela taxa_inadimplencia_percentual, destacando os tipos de tratamento com maiores taxas de inadimpl√™ncia e possibilitando √† empresa revisar pol√≠ticas de cobran√ßa, avaliar a viabilidade de parcelamentos e buscar melhores condi√ß√µes com seguradoras. Essa abordagem torna a an√°lise mais estrat√©gica e orientada √† tomada de decis√£o.


#### Resposta 1

Os resultados indicam que a taxa de inadimpl√™ncia √© alta em praticamente todos os tipos de tratamento, variando conforme a faixa de valor dos procedimentos. No caso do ECG, os tratamentos com custo acima de 3 mil reais apresentam uma inadimpl√™ncia extremamente elevada, com 93,33% dos casos em atraso ou n√£o pagos. J√° para a quimioterapia, mesmo os tratamentos mais baratos, com valor abaixo de 1 mil reais, apresentam uma inadimpl√™ncia alta, de 87,5%, enquanto os tratamentos caros dessa modalidade t√™m uma taxa de 75%. Tratamentos de fisioterapia na faixa m√©dia, entre 1 e 3 mil reais, tamb√©m mostram uma inadimpl√™ncia significativa, de aproximadamente 73,7%. Em geral, mesmo os tratamentos com valores m√©dios e baixos apresentam taxas altas, na faixa de 50% a 70%. Essa situa√ß√£o sugere que a inadimpl√™ncia n√£o est√° restrita apenas aos tratamentos mais caros, mas afeta de forma ampla diferentes tipos e faixas de valor. Esses dados indicam a necessidade de aten√ß√£o especial para os processos de cobran√ßa e acompanhamento financeiro, especialmente para os tratamentos de maior custo, que acumulam as maiores taxas de inadimpl√™ncia. Essa an√°lise pode servir para direcionar esfor√ßos e pol√≠ticas que visem a redu√ß√£o da inadimpl√™ncia, visando melhorar a sustentabilidade financeira do servi√ßo.

<div align="center">
<img width="549" height="334" alt="Image" src="https://github.com/user-attachments/assets/61839800-4862-4bbf-ae5b-47fe359e1952" />
</div>


### Pergunta, Descri√ß√£o e Resposta 2
#### Quest√£o 2

Existem m√©dicos ou especialidades em que a maioria dos atendimentos agendados resulta em cancelamento?

#### Descri√ß√£o 2

Nesta quest√£o, o objetivo foi analisar a taxa de cancelamento de atendimentos m√©dicos por m√©dico, especialidade e filial hospitalar. Para isso, utilizei as tabelas tb_act_appointments, que cont√©m os agendamentos e seus status, e tb_act_doctors, que traz informa√ß√µes sobre os m√©dicos, como a especialidade e a filial onde atendem. Como essas informa√ß√µes est√£o em tabelas diferentes, realizei uma jun√ß√£o do tipo LEFT JOIN, relacionando os registros pelo campo doctor_id. A consulta conta o total de atendimentos realizados e soma os atendimentos que foram cancelados, identificados pelo status ‚Äòcancelled‚Äô. Para calcular a taxa de cancelamento percentual, dividi o n√∫mero de cancelamentos pelo total de atendimentos, multiplicando o resultado por 100 e formatando para exibir duas casas decimais. Tamb√©m usei a fun√ß√£o NULLIF para evitar divis√£o por zero, caso n√£o haja atendimentos registrados para algum m√©dico. O agrupamento foi feito por m√©dico, especialidade e filial, permitindo assim observar detalhadamente onde e por quem os cancelamentos ocorrem com maior frequ√™ncia. Dessa forma, a view facilita o monitoramento e a an√°lise dos padr√µes de cancelamento nas diferentes √°reas e locais de atendimento.

```
create view vw_cancelamento as 

select 
	t2.doctor_id,
	t2.specialization,
	t2.hospital_branch,
	count (*) as total_atendimentos,
	sum(case 
			when t1.status = 'cancelled' then 1
			else 0
			end) as total_cancelado,
			format(100.0 * -- round: arredondar numeros  format: formatar o numero para texto 
				sum (case
						when t1.status = 'cancelled' then 1
						else 0
						end) / nullif(count(*), 0), 'N2') as taxa_cancelamento_percentual -- nullif: nao dividir por zero: se tiver zero amigos, nem tente dividir
from [dbo].[tb_act_appointments] as t1

left join [dbo].[tb_act_doctors] as t2
on t1.doctor_id = t2.doctor_id

group by t2.doctor_id, t2.specialization, t2.hospital_branch




select
	*
from vw_cancelamento

order by taxa_cancelamento_percentual desc
```

#### Resposta 2

Os dados mostram a taxa de cancelamento de atendimentos para diferentes m√©dicos, suas especialidades e as filiais onde atuam. O m√©dico D007, da especialidade Oncologia na filial Westside Clinic, apresenta a maior taxa de cancelamento, com 38,46% dos seus 13 atendimentos cancelados. Em seguida, o m√©dico D002, de Pediatria na Eastside Clinic, tem uma taxa semelhante, com 38,10% de cancelamentos em 21 atendimentos. Outros m√©dicos da especialidade Dermatologia e Pediatria tamb√©m apresentam taxas relevantes, variando entre cerca de 20% e 31%, indicando que uma parcela significativa dos atendimentos agendados por esses profissionais foi cancelada. M√©dicos como D010, da Oncologia na Eastside Clinic, apresentam uma taxa menor, com 15,79%.

<div align="center">
<img width="632" height="236" alt="Image" src="https://github.com/user-attachments/assets/15fbe945-3bdc-4a3b-9606-7f74aec729a4" />
</div>


Esses resultados podem sinalizar problemas espec√≠ficos relacionados √† agenda, comunica√ß√£o ou confian√ßa dos pacientes, especialmente para os m√©dicos com taxas de cancelamento mais elevadas. Al√©m disso, a varia√ß√£o das taxas entre filiais sugere que quest√µes operacionais locais podem influenciar o volume de cancelamentos. Essa an√°lise pode ajudar a identificar m√©dicos e unidades que necessitam de aten√ß√£o para reduzir cancelamentos e melhorar o atendimento.

### Pergunta, Descri√ß√£o e Resposta 3
#### Quest√£o 3

Como se distribuem os pacientes, considerando g√™nero e faixas et√°rias, em rela√ß√£o ao status das consultas (canceladas ou no-show), e qual o total de pacientes que ainda n√£o realizaram nenhuma consulta?

#### Descri√ß√£o 3

O objetivo dessa an√°lise √© compreender o perfil et√°rio e de g√™nero dos pacientes que n√£o comparecem √†s consultas ou que t√™m suas consultas canceladas, al√©m de identificar quantos pacientes ainda n√£o realizaram nenhum atendimento no sistema de sa√∫de.

Primeiramente, utilizei duas CTEs (Common Table Expressions) para organizar os dados em blocos distintos e facilitar a interpreta√ß√£o.

A primeira CTE, chamada pacientes_sem_consulta, identifica os pacientes que ainda n√£o realizaram nenhuma consulta, ou seja, cujos registros n√£o aparecem na tabela de agendamentos. Para isso, fiz um LEFT JOIN entre a tabela de pacientes e a de agendamentos, filtrando os casos em que o paciente n√£o possui correspond√™ncia na tabela de consultas (t2.patient_id IS NULL). Os dados foram agrupados por paciente, g√™nero e data de nascimento, permitindo calcular o total de pacientes sem consulta.

```

create view vw_agendamento_consulta as 

with pacientes_sem_consulta as (

select
	t1.patient_id,
	t1.gender,
	convert(date,t1.date_of_birth) as birth_date, -- remove a hora 
	count(*) as total_pacientes_sem_consulta
from [dbo].[tb_act_patients] as t1

left join [dbo].[tb_act_appointments] as t2
on t1.patient_id = t2.patient_id

where t2.patient_id is null 

group by t1.patient_id, t1.gender, t1.date_of_birth

), 

-- pacientes por idade e consultas canceladas ou no-show 

pacientes_com_cancelamento_ou_noshow as (
select
	t1.gender,
	count (*) as total_cancelamento_no_show,
	datediff(year, t1.date_of_birth, getdate()) as idade,
	t2.status 
from [dbo].[tb_act_patients] as t1

left join [dbo].[tb_act_appointments] as t2
on t1.patient_id = t2.patient_id

where t2.status in ('Cancelled', 'No-show')

group by t1.gender, t2.status, 	datediff(year, t1.date_of_birth, getdate())



	

), 


-- consultas_por_faixa_etaria_e_status

faixas_etarias as (
select
	gender,
	case
		when idade < 18 then 'Menor de 18'
		when idade between 18 and 29 then '18-29 anos'
		when idade between 30 and 44 then '30-44 anos'
		when idade between 45 and 59 then '45-59 anos'
		when idade >= 60 then '60 ou mais'
		else 'idade desconhecida'
		end as faixa_etaria,
		status, 
		count(*) as total
		from pacientes_com_cancelamento_ou_noshow

	group by 
			case
		when idade < 18 then 'Menor de 18'
		when idade between 18 and 29 then '18-29 anos'
		when idade between 30 and 44 then '30-44 anos'
		when idade between 45 and 59 then '45-59 anos'
		when idade >= 60 then '60 ou mais'
		else 'idade desconhecida'
		end,
		status,
		gender
)


-- resultado final 

select 
	*
from faixas_etarias



select	
	*
from vw_agendamento_consulta

order by faixa_etaria, status
```

A segunda CTE, pacientes_com_cancelamento_ou_noshow, analisa os pacientes que tiveram consultas com status ‚ÄúCancelled‚Äù ou ‚ÄúNo-show‚Äù, ou seja, n√£o compareceram ou cancelaram. Tamb√©m foi utilizada a jun√ß√£o entre as tabelas de pacientes e agendamentos, com um filtro espec√≠fico para esses dois status. Em seguida, foi calculada a idade dos pacientes com base na data de nascimento, e os dados foram agrupados por g√™nero, status da consulta e idade.


A terceira CTE, faixas_etarias, categoriza os pacientes da CTE anterior em faixas et√°rias pr√©-definidas (como ‚ÄúMenor de 18‚Äù, ‚Äú18‚Äì29 anos‚Äù, etc.), permitindo visualizar a distribui√ß√£o de cancelamentos e no-shows de forma segmentada por idade e g√™nero. O agrupamento por status, gender e faixa_etaria permite uma an√°lise cruzada entre essas vari√°veis.



Por fim, a consulta final seleciona todos os dados da CTE faixas_etarias, retornando uma tabela que mostra, para cada combina√ß√£o de faixa et√°ria, g√™nero e status da consulta, o total de ocorr√™ncias registradas. Essa estrutura facilita a identifica√ß√£o de padr√µes de comportamento entre grupos espec√≠ficos de pacientes, como maior incid√™ncia de no-show entre jovens ou maior n√∫mero de cancelamentos entre pacientes idosos, por exemplo.



#### Resposta 3

Os resultados revelam que pacientes do sexo masculino entre 18 e 29 anos concentram a maior quantidade de cancelamentos (7) e no-shows (5), quando comparados √†s mulheres da mesma faixa (2 cancelamentos e 1 no-show). Esse padr√£o de maior taxa de aus√™ncia masculina se mant√©m, embora com menor intensidade, nas faixas de 30 a 44 anos e de 45 a 59 anos. J√° na faixa dos 60 anos ou mais, o comportamento √© mais equilibrado entre homens e mulheres, tanto em cancelamentos quanto em faltas, ambos com 3 ocorr√™ncias cada.

<div align="center">
<img width="264" height="350" alt="Image" src="https://github.com/user-attachments/assets/0646d08e-eb82-4cc5-987b-443bb5cfcb54" />
</div>

Esses dados sugerem que jovens adultos do sexo masculino apresentam maior propens√£o a n√£o comparecer √†s consultas agendadas, o que pode impactar a efici√™ncia do servi√ßo e a gest√£o da agenda m√©dica.

### Conclus√£o

A an√°lise desenvolvida a partir do Hospital Management Dataset permitiu n√£o apenas responder a tr√™s quest√µes relevantes sobre inadimpl√™ncia, cancelamentos e perfil dos pacientes, mas tamb√©m demonstrar a aplica√ß√£o pr√°tica de conceitos de modelagem relacional, uso de CTEs, tratamento de dados nulos e segmenta√ß√µes por faixa et√°ria e financeira. Por meio de consultas SQL otimizadas e estruturadas, foi poss√≠vel identificar gargalos operacionais que afetam diretamente a sustentabilidade financeira e a qualidade do atendimento no ambiente hospitalar.

Destacam-se, por exemplo, os altos √≠ndices de inadimpl√™ncia associados a determinados tratamentos, como quimioterapia e ECG, e taxas significativas de cancelamento entre m√©dicos de determinadas especialidades e unidades, al√©m da concentra√ß√£o de no-shows entre homens jovens. Essas informa√ß√µes oferecem subs√≠dios importantes para decis√µes estrat√©gicas de gest√£o, como revis√£o de pol√≠ticas de cobran√ßa, ajustes nas agendas m√©dicas e campanhas de engajamento voltadas a grupos espec√≠ficos de pacientes.

O projeto demonstra, assim, a import√¢ncia de uma abordagem orientada a dados para melhorar processos, reduzir perdas e promover maior efici√™ncia no setor da sa√∫de.
